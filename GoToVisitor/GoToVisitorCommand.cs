using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Antlr4.Runtime;
using AntlrVSIX.Extensions;
using AntlrVSIX.Grammar;
using AntlrVSIX.Package;
using EnvDTE;
using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio.Text.Editor;
using Microsoft.VisualStudio.Text;
using Microsoft.VisualStudio.TextManager.Interop;
using System.ComponentModel.Design;
using System.IO;
using EnvDTE80;
using Microsoft.VisualStudio.Text.Classification;
using Microsoft.VisualStudio.Text.Operations;

namespace AntlrVSIX.GoToVisitor
{
    public class GoToVisitorCommand
    {
        private readonly Microsoft.VisualStudio.Shell.Package _package;
        private MenuCommand _menu_item1;
        private MenuCommand _menu_item2;

        private GoToVisitorCommand(Microsoft.VisualStudio.Shell.Package package)
        {
            if (package == null)
            {
                throw new ArgumentNullException("package");
            }
            _package = package;
            OleMenuCommandService commandService = this.ServiceProvider.GetService(
                typeof(IMenuCommandService)) as OleMenuCommandService;

            if (commandService == null)
            {
                throw new ArgumentNullException("OleMenuCommandService");
            }

            {
                // Set up hook for context menu.
                var menuCommandID = new CommandID(new Guid(AntlrVSIX.Constants.guidMenuAndCommandsCmdSet), 0x7005);
                _menu_item1 = new MenuCommand(this.MenuItemCallbackListener, menuCommandID);
                _menu_item1.Enabled = false;
                _menu_item1.Visible = true;
                commandService.AddCommand(_menu_item1);
            }
            {
                // Set up hook for context menu.
                var menuCommandID = new CommandID(new Guid(AntlrVSIX.Constants.guidMenuAndCommandsCmdSet), 0x7006);
                _menu_item2 = new MenuCommand(this.MenuItemCallbackVisitor, menuCommandID);
                _menu_item2.Enabled = false;
                _menu_item2.Visible = true;
                commandService.AddCommand(_menu_item2);
            }
        }

        public bool Enabled
        {
            set
            {
                if (_menu_item1 != null) _menu_item1.Enabled = value;
                if (_menu_item2 != null) _menu_item2.Enabled = value;
            }
        }

        public bool Visible
        {
            set
            {
                if (_menu_item1 != null) _menu_item1.Visible = value;
                if (_menu_item2 != null) _menu_item2.Visible = value;
            }
        }

        public static GoToVisitorCommand Instance { get; private set; }

        private IServiceProvider ServiceProvider
        {
            get { return this._package; }
        }

        public static void Initialize(Microsoft.VisualStudio.Shell.Package package)
        {
            Instance = new GoToVisitorCommand(package);
        }

        private void MenuItemCallbackVisitor(object sender, EventArgs e)
        {
            MenuItemCallback(sender, e, true);
        }

        private void MenuItemCallbackListener(object sender, EventArgs e)
        {
            MenuItemCallback(sender, e, false);
        }

        private void MenuItemCallback(object sender, EventArgs e, bool visitor)
        {
            // Return if I can't determine what application this is.
            DTE application = DteExtensions.GetApplication();
            if (application == null) return;

            // Get active view and determine if it's a grammar file.
            var view = AntlrLanguagePackage.Instance.GetActiveView();
            if (view == null) return;
            ITextCaret car = view.Caret;
            CaretPosition cp = car.Position;
            SnapshotPoint bp = cp.BufferPosition;
            int pos = bp.Position;
            ITextBuffer buffer = view.TextBuffer;
            ITextDocument doc = buffer.GetTextDocument();
            string g4_file_path = doc.FilePath;
            if (Path.GetExtension(g4_file_path).ToLower() != ".g4") return;

            // Get name of base class for listener and visitor. These are generated by Antlr,
            // constructed from the name of the file.
            var name = Path.GetFileName(doc.FilePath);
            name = Path.GetFileNameWithoutExtension(name);
            var listener_baseclass_name = visitor ? (name + "BaseVisitor") : (name + "BaseListener");
            var listener_class_name = visitor ? ("My" + name + "Visitor") : ("My" + name + "Listener");

            // In the current view, find the details of the Antlr symbol at the cursor.
            TextExtent extent = AntlrVSIX.Package.AntlrLanguagePackage.Instance.Navigator[view].GetExtentOfWord(bp);
            SnapshotSpan span = extent.Span;
            AntlrLanguagePackage.Instance.Span = span;

            //  Now, check for valid classification type.
            ClassificationSpan[] c1 = AntlrVSIX.Package.AntlrLanguagePackage.Instance.Aggregator[view]
                .GetClassificationSpans(span).ToArray();
            foreach (ClassificationSpan classification in c1)
            {
                var cname = classification.ClassificationType.Classification.ToLower();
                if (cname == AntlrVSIX.Constants.ClassificationNameTerminal)
                {
                    AntlrLanguagePackage.Instance.Classification = AntlrVSIX.Constants.ClassificationNameTerminal;
                }
                else if (cname == AntlrVSIX.Constants.ClassificationNameNonterminal)
                {
                    AntlrLanguagePackage.Instance.Classification = AntlrVSIX.Constants.ClassificationNameNonterminal;
                }
                else if (cname == AntlrVSIX.Constants.ClassificationNameLiteral)
                {
                    AntlrLanguagePackage.Instance.Classification = AntlrVSIX.Constants.ClassificationNameLiteral;
                }
            }

            // Determine if the symbol is a rule symbol. The symbol has to be a nonterminal.
            List<IToken> where = new List<IToken>();
            List<ParserDetails> where_details = new List<ParserDetails>();
            IToken token = null;
            foreach (var kvp in ParserDetails._per_file_parser_details)
            {
                string file_name = kvp.Key;
                ParserDetails details = kvp.Value;
                if (AntlrLanguagePackage.Instance.Classification == AntlrVSIX.Constants.ClassificationNameNonterminal)
                {
                    var it = details._ant_nonterminals_defining.Where(
                        (t) => t.Text == span.GetText());
                    where.AddRange(it);
                    foreach (var i in it) where_details.Add(details);
                }
            }

            if (where.Any()) token = where.First();
            else return;

            // Get the symbol name as a string.
            var sym = token.Text;

            // Parse all the C# files in the solution.
            Dictionary<string, SyntaxTree> trees = new Dictionary<string, SyntaxTree>();
            foreach (var item in DteExtensions.SolutionFiles(application))
            {
                string file_name = item.Name;
                if (file_name != null)
                {
                    string prefix = file_name.TrimSuffix(".cs");
                    if (prefix == file_name) continue;
                    try
                    {
                        object prop = item.Properties.Item("FullPath").Value;
                        string ffn = (string) prop;
                        StreamReader sr = new StreamReader(ffn);
                        string code = sr.ReadToEnd();
                        SyntaxTree tree = CSharpSyntaxTree.ParseText(code);
                        trees[ffn] = tree;
                    }
                    catch (Exception eeks)
                    {
                    }
                }
            }

            // Find first occurence of visitor class.
            ClassDeclarationSyntax found_class = null;
            string class_file_path = null;
            try
            {
                foreach (var kvp in trees)
                {
                    var file_name = kvp.Key;
                    var tree = kvp.Value;

                    // Look for IParseTreeListener or IParseTreeVisitor classes.
                    var root = (CompilationUnitSyntax)tree.GetRoot();
                    if (root == null) continue;
                    foreach (var nm in root.Members)
                    {
                        var namespace_member = nm as NamespaceDeclarationSyntax;
                        if (namespace_member == null) continue;
                        foreach (var cm in namespace_member.Members)
                        {
                            var class_member = cm as ClassDeclarationSyntax;
                            if (class_member == null) continue;
                            var bls = class_member.BaseList;
                            if (bls == null) continue;
                            var types = bls.Types;
                            foreach (var type in types)
                            {
                                var s = type.ToString();
                                if (s.ToString() == listener_baseclass_name)
                                {
                                    // Found the right class.
                                    found_class = class_member;
                                    class_file_path = file_name;
                                    throw new Exception();
                                }
                            }
                        }
                    }
                }
            }
            catch
            {
            }

            if (found_class == null)
            {
                // Look in grammar directory for any C# files.
                string name_space = null;
                string ffn = Path.GetFullPath(g4_file_path);
                ffn = Path.GetDirectoryName(ffn);
                foreach (var i in DteExtensions.SolutionFiles(application))
                {
                    string file_name = i.Name;
                    if (file_name != null)
                    {
                        string prefix = file_name.TrimSuffix(".cs");
                        if (prefix == file_name) continue;
                        try
                        {
                            object prop = i.Properties.Item("FullPath").Value;
                            string ffncs = (string)prop;
                            // Look for namespace.
                            var t = trees[ffncs];
                            if (t == null) continue;
                            var root = t.GetCompilationUnitRoot();
                            foreach (var nm in root.Members)
                            {
                                var namespace_member = nm as NamespaceDeclarationSyntax;
                                if (namespace_member == null) continue;
                                name_space = namespace_member.Name.ToString();
                                break;
                            }
                        }
                        catch (Exception eeks)
                        {
                        }
                    }
                }
                if (name_space == null) name_space = "Generated";

                // Create class.
                string clazz = visitor ? $@"
using System;
using System.Collections.Generic;
using System.Text;

namespace {name_space}
{{
    class {listener_class_name}<Result> : {listener_baseclass_name}<Result>
    {{
        //public override Result VisitA([NotNull] A3Parser.AContext context)
        //{{
        //  return VisitChildren(context);
        //}}
    }}
}}
"
                : $@"
using System;
using System.Collections.Generic;
using System.Text;

namespace {name_space}
{{
    class {listener_class_name} : {listener_baseclass_name}
    {{
        //public override void EnterA(A3Parser.AContext context)
        //{{
        //    base.EnterA(context);
        //}}
        //public override void ExitA(A3Parser.AContext context)
        //{{
        //    base.ExitA(context);
        //}}
    }}
}}
";

                ffn = ffn + Path.DirectorySeparatorChar + listener_class_name + ".cs";
                System.IO.File.WriteAllText(ffn, clazz);
                object item = ProjectHelpers.GetSelectedItem();
                string folder = FindFolder(item);
                if (string.IsNullOrEmpty(folder) || !Directory.Exists(folder))
                    return;
                var file = new FileInfo(ffn);
                var selectedItem = item as ProjectItem;
                var selectedProject = item as Project;
                Project project = selectedItem?.ContainingProject ?? selectedProject ?? null;
                var projectItem = project.AddFileToProject(file);
                // Redo parse.
                try
                {
                    StreamReader sr = new StreamReader(ffn);
                    string code = sr.ReadToEnd();
                    SyntaxTree tree = CSharpSyntaxTree.ParseText(code);
                    trees[ffn] = tree;
                }
                catch (Exception eeks)
                {
                }
                try
                {
                    var tree = trees[ffn];
                    // Look for IParseTreeListener or IParseTreeVisitor classes.
                    var root = (CompilationUnitSyntax)tree.GetRoot();
                    foreach (var nm in root.Members)
                    {
                        var namespace_member = nm as NamespaceDeclarationSyntax;
                        if (namespace_member == null) continue;
                        foreach (var cm in namespace_member.Members)
                        {
                            var class_member = cm as ClassDeclarationSyntax;
                            if (class_member == null) continue;
                            var bls = class_member.BaseList;
                            if (bls == null) continue;
                            var types = bls.Types;
                            foreach (var type in types)
                            {
                                var s = type.ToString();
                                if (s.ToString() == listener_baseclass_name)
                                {
                                    // Found the right class.
                                    found_class = class_member;
                                    class_file_path = ffn;
                                    throw new Exception();
                                }
                            }
                        }
                    }
                }
                catch
                {
                }
            }

            // Look for enter or exit method for symbol.
            MethodDeclarationSyntax found_member = null;
            try
            {
                var to_find = visitor ? ("Visit" + sym) : ("Enter" + sym);
                foreach (var me in found_class.Members)
                {
                    var method_member = me as MethodDeclarationSyntax;
                    if (method_member == null) continue;
                    if (method_member.Identifier.ValueText.ToLower() == to_find.ToLower())
                    {
                        found_member = method_member;
                        throw new Exception();
                    }
                }
            }
            catch
            {
            }
            if (found_member == null)
            {
                // Find point for edit.
                var here = found_class.OpenBraceToken;
                var spn = here.FullSpan;
                var end = spn.End;
                
            }

            {
                // Open to this line in editor.
                IVsTextView vstv = IVsTextViewExtensions.GetIVsTextView(class_file_path);
                IVsTextViewExtensions.ShowFrame(class_file_path);
                vstv = IVsTextViewExtensions.GetIVsTextView(class_file_path);

                IWpfTextView wpftv = vstv.GetIWpfTextView();
                if (wpftv == null) return;

                int line_number;
                int colum_number;
                var txt_span = found_member.Identifier.Span;
                vstv.GetLineAndColumn(txt_span.Start, out line_number, out colum_number);

                // Create new span in the appropriate view.
                ITextSnapshot cc = wpftv.TextBuffer.CurrentSnapshot;
                SnapshotSpan ss = new SnapshotSpan(cc, txt_span.Start, txt_span.Length);
                SnapshotPoint sp = ss.Start;
                // Put cursor on symbol.
                wpftv.Caret.MoveTo(sp); // This sets cursor, bot does not center.
                // Center on cursor.
                //wpftv.Caret.EnsureVisible(); // This works, sort of. It moves the scroll bar, but it does not CENTER! Does not really work!
                if (line_number > 0)
                    vstv.CenterLines(line_number - 1, 2);
                else
                    vstv.CenterLines(line_number, 1);
                return;
            }
        }

        private static string FindFolder(object item)
        {
            if (item == null)
                return null;
            DTE application = DteExtensions.GetApplication();
            if (application == null) return "";
            if (application.ActiveWindow is Window2 window && window.Type == vsWindowType.vsWindowTypeDocument)
            {
                // if a document is active, use the document's containing directory
                Document doc = application.ActiveDocument;
                if (doc != null && !string.IsNullOrEmpty(doc.FullName))
                {
                    ProjectItem docItem = application.Solution.FindProjectItem(doc.FullName);

                    if (docItem != null && docItem.Properties != null)
                    {
                        string fileName = docItem.Properties.Item("FullPath").Value.ToString();
                        if (System.IO.File.Exists(fileName))
                            return Path.GetDirectoryName(fileName);
                    }
                }
            }

            string folder = null;

            var projectItem = item as ProjectItem;
            if (projectItem != null && "{6BB5F8F0-4483-11D3-8BCF-00C04F8EC28C}" == projectItem.Kind) //Constants.vsProjectItemKindVirtualFolder
            {
                ProjectItems items = projectItem.ProjectItems;
                foreach (ProjectItem it in items)
                {
                    if (System.IO.File.Exists(it.FileNames[1]))
                    {
                        folder = Path.GetDirectoryName(it.FileNames[1]);
                        break;
                    }
                }
            }
            else
            {
                var project = item as Project;
                if (projectItem != null)
                {
                    string fileName = projectItem.FileNames[1];

                    if (System.IO.File.Exists(fileName))
                    {
                        folder = Path.GetDirectoryName(fileName);
                    }
                    else
                    {
                        folder = fileName;
                    }
                }
                else if (project != null)
                {
                    folder = project.GetRootFolder();
                }
            }
            return folder;
        }

    }
}
